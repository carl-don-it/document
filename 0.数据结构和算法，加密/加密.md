# md5摘要算法

MD5只是一种哈希算法，一般用来计算摘要，将不定长的输入转化为128bit的散列结果，而这种hash算法的计算过程就是不停的移位不停的与或非的，计算起来很快。当然，大部分哈希都这样。

和哈希表的散列函数作用一样。

最常用的情况就是用户下载完文件以后，用MD5算法计算下载文件的MD5校验和，然后通过检查与服务器之前提供的校验和是否一致，就能判断下载的文件是否出错或者被修改过了。

**很多应用的md5哈希算法生成的结果都一样，直接使用util类就行了。**

# 非对称加密

https://www.zhihu.com/question/20874499

https://www.zhihu.com/question/33645891

https://www.zhihu.com/question/312961692

## RSA算法

大质数。

相当于数学问题，不必深究。

问题是两个随机大质数怎么生成而别人又不知道生成算法。

[维基百科](https://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95)

[RSA算法原理（一）](https://link.zhihu.com/?target=http%3A//www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html)
[RSA算法原理（二）](https://link.zhihu.com/?target=http%3A//www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html)

[www.toolnb.com](https://www.toolnb.com/tools/testrsa.html)

看一个小时候经常在《趣味数学》这类书里的一个数学小魔术：

让对方任意想一个3位数，并把这个数和91相乘，然后告诉我积的最后三位数，我就可以猜出对方想的是什么数字啦！比如对方想的是123，那么对方就计算出123 * 91等于11193，并把结果的末三位193告诉我。看起来，这么做似乎损失了不少信息，让我没法反推出原来的数。不过，我仍然有办法：只需要把对方告诉我的结果再乘以11，乘积的末三位就是对方刚开始想的数了。可以验证一下，193 * 11 = 2123，末三位正是对方所想的秘密数字！

其实道理很简单，91乘以11等于1001，而任何一个三位数乘以1001后，末三位显然都不变（例如123乘以1001就等于123123）。

知道原理后，我们可以构造一个定义域和值域更大的加密解密系统。比方说，任意一个数乘以400000001后，末8位都不变，而400000001 = 19801 * 20201，于是你来乘以19801，我来乘以20201，又一个加密解密不对称的系统就构造好了。

甚至可以构造得更大一些：4000000000000000000000000000001 = 1199481995446957 * 3334772856269093，这样我们就成功构造了一个30位的加密系统。

这是一件非常coooooooool的事情，任何人都可以按照我公布的方法加密一个数，但是只有我才知道怎么把所得的密文变回去。

其安全性就建立在算乘积非常容易，但是要把4000000000000000000000000000001分解成后面两个数相乘，在没有计算机的时代几乎不可能成功！但如果仅仅按照上面的思路，如果对方知道原理，知道我要构造出带很多0的数，根据19801和8位算法这2个条件非常容易穷举出400000001这个目标值。

要解决这个问题，真实世界就不是使用乘法了，比如RSA算法使用的是指数和取模运算，但本质上就是上面这套思想。

