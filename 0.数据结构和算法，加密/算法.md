# 为什么学算法

学习什么时候以及如何将不同的数据结构运用到自己的代码里。忘掉细枝末节的东西，而更关注：什么时候需要hash？什么时候需要tree？什么时候最小化堆是正确的答案？

感谢答主，现在越学感悟越大，以前总关注这个工具/框架/...怎么用，现在更多会问自己为什么是它？它有什么用？它适用场合是什么？它有什么缺点吗？它对比类似的东东有什么特点或者优势？

1，你不学怎么知道用哪个api？

2，有的问题有好几种算法都适合，不学怎么知道用其中哪一个？

3，如果遇到了经典算法解决不了的综合性问题，或者开源软件提供的库没有预料到的情况需要优化。没有通过经典算法学到计算机思维，你怎么解决？

其实学习算法并不是主要学习算法本身，那玩意死记硬背都能背下来，最重要的是通过这些经典算法了解计算机能做什么，通过什么途径做最高效，当问题过于复杂时，如何在人脑的限制下指挥计算机完成人类无法直接完成的工作（比如从1加到一亿的素数）

你要通过算法知道计算机不同于人类常规思维的特殊思维方式，它为什么要这样解决问题

要不然学了也是白学

优化算法什么的大部分人都做不到那都不谈了

作者：法兰克斯雪诺

链接：https://www.zhihu.com/question/56915780/answer/151088965

来源：知乎

著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



**时间复杂度和空间复杂度的平衡。**

知道原理，然后会选会用。

# 算法书

编程书籍里面有

# 深度优先遍历（DFS）和广度优先遍历（BFS）

https://developer.51cto.com/art/202004/614590.htm

# 雪花算法

https://zhuanlan.zhihu.com/p/85837641

# 加密算法

## md5摘要算法

MD5只是一种哈希算法，一般用来计算摘要，将不定长的输入转化为128bit的散列结果，而这种hash算法的计算过程就是不停的移位不停的与或非的，计算起来很快。当然，大部分哈希都这样。

和哈希表的散列函数作用一样。

最常用的情况就是用户下载完文件以后，用MD5算法计算下载文件的MD5校验和，然后通过检查与服务器之前提供的校验和是否一致，就能判断下载的文件是否出错或者被修改过了。

**很多应用的md5哈希算法生成的结果都一样，直接使用util类就行了。**

## 非对称加密

https://www.zhihu.com/question/20874499

https://www.zhihu.com/question/33645891

https://www.zhihu.com/question/312961692

### RSA算法

大质数。

相当于数学问题，不必深究。

问题是两个随机大质数怎么生成而别人又不知道生成算法。

[维基百科](https://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95)

[RSA算法原理（一）](https://link.zhihu.com/?target=http%3A//www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html)
[RSA算法原理（二）](https://link.zhihu.com/?target=http%3A//www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html)

[www.toolnb.com](https://www.toolnb.com/tools/testrsa.html)

看一个小时候经常在《趣味数学》这类书里的一个数学小魔术：

让对方任意想一个3位数，并把这个数和91相乘，然后告诉我积的最后三位数，我就可以猜出对方想的是什么数字啦！比如对方想的是123，那么对方就计算出123 * 91等于11193，并把结果的末三位193告诉我。看起来，这么做似乎损失了不少信息，让我没法反推出原来的数。不过，我仍然有办法：只需要把对方告诉我的结果再乘以11，乘积的末三位就是对方刚开始想的数了。可以验证一下，193 * 11 = 2123，末三位正是对方所想的秘密数字！

其实道理很简单，91乘以11等于1001，而任何一个三位数乘以1001后，末三位显然都不变（例如123乘以1001就等于123123）。

知道原理后，我们可以构造一个定义域和值域更大的加密解密系统。比方说，任意一个数乘以400000001后，末8位都不变，而400000001 = 19801 * 20201，于是你来乘以19801，我来乘以20201，又一个加密解密不对称的系统就构造好了。

甚至可以构造得更大一些：4000000000000000000000000000001 = 1199481995446957 * 3334772856269093，这样我们就成功构造了一个30位的加密系统。

这是一件非常coooooooool的事情，任何人都可以按照我公布的方法加密一个数，但是只有我才知道怎么把所得的密文变回去。

其安全性就建立在算乘积非常容易，但是要把4000000000000000000000000000001分解成后面两个数相乘，在没有计算机的时代几乎不可能成功！但如果仅仅按照上面的思路，如果对方知道原理，知道我要构造出带很多0的数，根据19801和8位算法这2个条件非常容易穷举出400000001这个目标值。

要解决这个问题，真实世界就不是使用乘法了，比如RSA算法使用的是指数和取模运算，但本质上就是上面这套思想。

