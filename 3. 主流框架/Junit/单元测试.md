# 基础

如果单元测试测得通那就直接测，不需要mock数据。

如果程序还没有写好，或者第三方没有调通，可以mock。

如果要测试http请求，那么最好mock第三方server（会发送完整的http，也是请求，只不过服务器是我们自己mock的，看http请求是否写得准确。），否则直接把整个类mock掉。



# spring的测试

> spring的测试分为两仲，一种是启动整个服务器和容器，另一个仲是模拟服务器。
>
> ```
> @RunWith(SpringRunner.class)
> @SpringBootTest(classes = CrawlAdminApplication.class,
>         webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT
> )
> ```
>
> ```
> @RunWith(SpringRunner.class)
> @SpringBootTest(classes = CrawlAdminApplication.class)
> @AutoConfigureMockMvc //注解配置一个mockmvc
> ```
>
> 

[玩转单元测试之WireMock -- Web服务模拟器](https://www.cnblogs.com/wade-xu/p/4299710.html)

> 构建一个WireMockServer，注入一些服务，来测试http，可用来模拟**第三方**，不需要依赖spring。
>
> 不仅可以设置一个服务器，还可以不同的http对应不同的host（在stubfor中设置）。

[就是这么简单(续)！使用 RestAssuredMockMvc 测试 Spring MVC Controllers ](https://www.cnblogs.com/wade-xu/p/4311205.html)

> 测试mvc的。mock一个server装载controller去测试。，没用

[玩转单元测试之Testing Spring MVC Controllers](https://www.cnblogs.com/wade-xu/p/4311657.html)

> 和上面一样，也是测试controller的东西。，单元测试，和集成测试。

[玩转单元测试之DBUnit ](https://www.cnblogs.com/wade-xu/p/4547381.html)

> 没用上，数据库的

[就是这么简单！使用Rest-assured 测试Restful Web Services ](https://www.cnblogs.com/wade-xu/p/4298819.html)

> 测试http的东西

Spring Boot实战 ,丁雪丰 (译者) 

> 测试mvc，mock一个server装载controller或者一整个spring去测试mvc
>
> 测试spring security

[单纯测mvc](https://blog.csdn.net/qq_28165595/article/details/123762562)

> ```
> @WebMvcTest(SpringTestController.class)
> @RunWith(SpringRunner.class)
> public class MockTest {
>  
>     @Autowired
>     private MockMvc mockMvc;
>  
>     private static final Logger LOGGER= LoggerFactory.getLogger(MockTest.class);
>     
>     @Test
>     public void testMockStudent() throws Exception {
>         MvcResult result = mockMvc.perform(MockMvcRequestBuilders.
>                 get("/test/mockTest")).andReturn();
>         String content = result.getResponse().getContentAsString();
>         Student student = JSONObject.parseObject(content, Student.class);
>         LOGGER.info(student.toString());
>     }
> }
> ```
>
> 只是注入一个模拟服务器和controller层，单纯测mvc

# json

[技术那么多，你想看看JSON Schema的测试吗？ ](https://www.cnblogs.com/wade-xu/p/4662127.html)

> 测试schema的东西

# wiremock

是一个api mock工具，用来mock server的。可以配合junit使用或者是java代码，底层都是启动一个wiremockserver然后stub。

[WireMock 使用](https://blog.csdn.net/qq_35787138/article/details/112474009)

https://wiremock.org/

https://www.baeldung.com/introduction-to-wiremock

[Mock技术的深度理解及WireMock框架基础使用](https://blog.csdn.net/qq_36792120/article/details/121770715)

[结合spring-boot做集成测试](https://github.com/carl-don-it/mockmvc)

```java
package com.dc.dmc.crawl.admin;

import com.github.tomakehurst.wiremock.WireMockServer;
import com.github.tomakehurst.wiremock.core.WireMockConfiguration;
import com.github.tomakehurst.wiremock.http.JvmProxyConfigurer;
import lombok.extern.slf4j.Slf4j;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.HttpHeaders;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;
import org.springframework.test.web.servlet.result.MockMvcResultHandlers;
import org.springframework.test.web.servlet.result.MockMvcResultMatchers;

import javax.annotation.Resource;

@Slf4j
@SpringBootTest(classes = CrawlAdminApplication.class, webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureMockMvc //注解配置一个mockmvc
public class CrawlAdminApplicationTest {

    @Resource
    MockMvc mockMvc;

    private WireMockServer wireMockServer;

    @Before
    public void setup() {
        // 开一个模拟的服务器，代表第三方
        wireMockServer = new WireMockServer(WireMockConfiguration.options()
                .enableBrowserProxying(true)
                .dynamicPort()
                .dynamicHttpsPort()
                .trustAllProxyTargets(true));
        wireMockServer.start();
        //代理所有请求
        JvmProxyConfigurer.configureFor(wireMockServer);
    }

    @After
    public void destroy() {
        wireMockServer.stop();
        JvmProxyConfigurer.restorePrevious();
    }

    @Test
    public void test1() throws Exception {
        //模拟请求，也可以直接发起一个http请求，没啥区别，测试用前者吧
        mockMvc.perform(MockMvcRequestBuilders.post("/crawl/sdfsd")
                .content("{}")
                .headers(new HttpHeaders()))
                .andExpect(MockMvcResultMatchers.status().is4xxClientError())
                .andDo(MockMvcResultHandlers.print())
                .andReturn();

    }
}
```

![image-20230428161019989](img/image-20230428161019989.png)

# 发现问题

mock urlpathequalto需要全部的url

# 插件

[Squaretest](https://blog.51cto.com/u_13260163/5296936)

[RestfulToolk](https://cloud.tencent.com/developer/article/1772885)

# junit

> 基本的测试框架。

[Junit-jupiter-api 和 junit-jupiter-engine 的区别是什么](https://blog.csdn.net/huyuchengus/article/details/109039316)

> - 你需要 `junit-jupiter-api` 和 `junit-jupiter-engine` 来在 Junit 5 中书写和运行测试。
> - 还需要launch。某些idea版本有问题的。
> - 针对老的 JUnit 4 的的项目，你需要将 `junit-jupiter-engine` 引擎替换为 `junit-vintage-engine` 引擎才能够让你的测试正式跑起来。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>groupId</groupId>
    <artifactId>junit5demo</artifactId>
    <version>1.0-SNAPSHOT</version>

    <dependencies>

        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.13-beta-3</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.junit.platform</groupId>
            <artifactId>junit-platform-launcher</artifactId>
            <version>1.0.1</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter-engine</artifactId>
            <version>5.0.1</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.junit.vintage</groupId>
            <artifactId>junit-vintage-engine</artifactId>
            <version>4.12.1</version>
            <scope>test</scope>
        </dependency>

    </dependencies>

 <build>
         <plugins>
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-compiler-plugin</artifactId>
                 <configuration>
                     <target>1.8</target>
                     <source>1.8</source>
                     <encoding>UTF-8</encoding>
                     <showWarnings>true</showWarnings>
                 </configuration>
             </plugin>
         </plugins>
     </build>
</project>
```

明显看出和Junit4 还是有些不同的。首先，导入测试测试注解（@Test）和断言方法（assertEquals）的路径不同。其次，不需要手动把测试和测试方法声明为 public 了。

```java
package com.itheima.test;

import org.junit.jupiter.api.*;

import static junit.framework.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import static org.junit.jupiter.api.Assertions.assertAll;

public class Junit5UseDemo {



	@BeforeEach
	@DisplayName("每条用例开始时执行")
	void start() {
		
	}

	@AfterEach
	@DisplayName("每条用例结束时执行")
	void end() {

	}

	@Test
	void myFirstTest() {
		assertEquals(2, 1 + 1);
	}

	@Test
	@DisplayName("描述测试用例╯°□°）╯")
	void testWithDisplayName() {

	}

	@Test
	@Disabled("这条用例暂时跑不过，忽略!")
	void myFailTest() {
		assertEquals(1, 2);
	}

	@Test
	@DisplayName("运行一组断言")
	public void assertAllCase() {
		assertAll("groupAssert", () -> assertEquals(2, 1 + 1), () -> assertTrue(1 > 0));
	}

	@Test
	@DisplayName("依赖注入1")
	public void testInfo(final TestInfo testInfo) {
		System.out.println(testInfo.getDisplayName());
	}

	@Test
	@DisplayName("依赖注入2")
	public void testReporter(final TestReporter testReporter) {
		testReporter.publishEntry("name", "Alex");
	}

}

```

![image-20200129130523599](../../3.%20%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6/Junit/img/image-20200129130523599.png)

### 原理

junit集成了一个main方法
该方法就会判断当前测试类中哪些方法有 @Test注解
junit就让有Test注解的方法执行  

使用

如果依赖有<scope>test</scope>，那么main包不会检测到类路径

```
* Junit使用：白盒测试
	* 步骤：
		1. 定义一个测试类(测试用例)
			* 建议：
				* 测试类名：被测试的类名Test		CalculatorTest
				* 包名：xxx.xxx.xx.test		cn.itcast.test

		2. 定义测试方法：可以独立运行
			* 建议：必须使public
				* 方法名：test测试的方法名		testAdd()  
				* 返回值：void
				* 参数列表：空参

		3. 给方法加@Test
		4. 导入junit依赖环境

	* 判定结果：
		* 红色：失败
		* 绿色：成功
		* 一般我们会使用断言操作来处理结果
			* Assert.assertEquals(期望的结果,运算的结果);

	* 补充：
		* @Before:
			* 修饰的方法会在测试方法之前被自动执行
		* @After:
			* 修饰的方法会在测试方法执行之后自动被执行
```

![image-20200121100750652](../../3.%20%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6/Junit/img/image-20200121100750652.png)

[junit5指定@Test的执行顺序](https://www.cnblogs.com/bky2020bky/p/13343101.html)