# 介绍

技术上来说，锁也可以理解成将大量并发请求**串行化**，但请注意**串行化**不能简单等同为** 排队 **，因为这里和现实世界没什么不同，排队意味着大家是**公平Fair**的领到资源，先到先得，然而很多情况下为了性能考量多线程之间还是会**不公平Unfair**的去抢。`Java中ReentrantLock可重入锁，提供了公平锁和非公平锁两种实现`

再注意一点，串行也不是意味着只有一个排队的队伍，每次只能进一个。当然可以好多个队伍，每次进入多个。比如餐馆一共10个餐桌，服务员可能一次放行最多10个人进去，有人出来再放行同数量的人进去。`Java中Semaphore信号量，相当于同时管理一批锁`



# 锁分类

## 自旋锁 

Spin Lock

自旋锁如果已经被别的线程获取，**调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，**”自旋”一词就是因此而得名。

自旋锁是一种**非阻塞**锁，也就是说，如果某线程需要获取自旋锁，但该锁已经被其他线程占用时，该线程不会被挂起，而是在不断的消耗CPU的时间，不停的试图获取自旋锁。

Java没有默认的自旋锁实现，示例代码如下：
```java
public class SpinLock {
	private AtomicReference<Thread> sign =new AtomicReference<>();
	public void lock() {
		Thread current = Thread.currentThread();
		while(!sign .compareAndSet(null, current)) {
		}
	}
	public void unlock () {
		Thread current = Thread.currentThread();
		sign .compareAndSet(current, null);
	}
}
```

通过示例，可以看到CAS原子操作将sign从期望的null设置为当前线程，线程A第一次调用lock()可以获取锁，第二次调用将进入循环等待，因为sign已经被设置为了current。

简单加个当前锁的owner比对判断和锁计数器，即可实现重入。

## 互斥锁 

Mutex Lock

互斥锁是阻塞锁，当某线程无法获取互斥锁时，该线程会被**直接挂起**，不再消耗CPU时间，当其他线程释放互斥锁后，操作系统会唤醒那个被挂起的线程。

阻塞锁可以说是让线程进入阻塞状态进行等待，当获得相应的信号（唤醒，时间）时，才可以进入线程的准备就绪状态，准备就绪状态的所有线程，通过竞争进入运行状态。它的优势在于，阻塞的线程不会占用 CPU 时间， 不会导致 CPU 占用率过高，但进入时间以及恢复时间都要比自旋锁略慢。**在竞争激烈的情况下阻塞锁的性能要明显高于自旋锁。**

JAVA中，能够进入/退出、阻塞状态或包含阻塞锁的方法有:

```
synchronized
ReentrantLock
Object.wait()/notify()
LockSupport.park()/unpart()(j.u.c经常使用)
```

## **自旋锁 VS 互斥锁**

两种锁适用于不同场景：
 如果是多核处理器，预计线程等待锁的时间很短，短到比线程两次上下文切换时间要少的情况下，使用**自旋锁**是划算的。**竞争不激烈**。

如果是多核处理器，如果预计线程等待锁的时间较长，至少比两次线程上下文切换的时间要长，建议使用**互斥锁**。**竞争激烈**。

如果是单核处理器，一般建议**不要使用自旋锁**。因为，在同一时间只有一个线程是处在运行状态，那如果运行线程发现无法获取锁，只能等待解锁，但因为自身不挂起，所以那个获取到锁的线程没有办法进入运行状态，只能等到运行线程把操作系统分给它的时间片用完，才能有机会被调度。这种情况下使用自旋锁的代价很高。

如果加锁的代码经常被调用，但竞争情况很少发生时，应该优先考虑使用**自旋锁**，自旋锁的开销比较小，互斥量的开销较大。

## 可重入锁 

Reentrant Lock

可重入锁是一种特殊的互斥锁，它可以被同一个线程多次获取，而不会产生死锁。

首先它是互斥锁：任意时刻，只有一个线程锁。即假设A线程已经获取了锁，在A线程释放这个锁之前，B线程是无法获取到这个锁的，B要获取这个锁就会进入阻塞状态。
其次，它可以被同一个线程多次持有。即，假设A线程已经获取了这个锁，如果A线程在释放锁之前又一次请求获取这个锁，那么是能够获取成功的。

```
Java中的synchronized, ReentrantLock都是可重入锁。
```

## 轻量级锁 & 偏向锁

Lightweight Lock，Biased Lock

首先互斥是一种会导致线程挂起，并在较短时间内又需要重新调度回原线程的，较为消耗资源的操作。

Java6为了减少获得锁和释放锁所带来的性能消耗，引入了“偏向锁”和“轻量级锁”，所以在Java6里锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。
数据库中针对不同的锁层级(Lock Hierarchy，表/页/行等)，
也有类似锁升级(Lock Escalations)的理念。

## 分布式锁

### 线程锁，进程锁，分布式锁

**线程锁: **大家都不陌生，主要用来给方法、代码块加锁。当某个方法或者代码块使用锁时，那么在同一时刻至多仅有有一个线程在执行该段代码。当有多个线程访问同一对象的加锁方法/代码块时，同一时间只有一个线程在执行，其余线程必须要等待当前线程执行完之后才能执行该代码段。但是，其余线程是可以访问该对象中的非加锁代码块的。

**进程锁: **也是为了控制同一操作系统中多个进程访问一个共享资源，只是因为程序的独立性，各个进程是无法控制其他进程对资源的访问的，但是可以使用本地系统的信号量控制（操作系统基本知识）。

**分布式锁: **当多个进程不在同一个系统之中时，使用分布式锁控制多个进程对资源的访问。

**区别：**线程锁，进程锁，分布式锁的作用都是一样的，只是作用的范围大小不同。范围大小:分布式锁——大于——进程锁——大于——线程锁。能用线程锁，进程锁情况下使用分布式锁也是可以的，能用线程锁的情况下使用进程锁也是可以的。只是范围越大技术复杂度就越大。

### 实现

#### 介绍

实现分布式锁必须要依靠第三方存储介质来存储锁的元数据等信息。比如分布式集群要操作某一行数据时，这个数据的流水号是唯一的，那么我们就把这个流水号作为一把锁的id，当某进程要操作该数据时，先去第三方存储介质中看该锁id是否存在，如果不存在，则将该锁id写入，然后执对该数据的操作；当其他进程要访问这个数据时，会先到第三方存储介质中查看有没有这个数据的锁id,有的话就认为这行数据目前已经有其他进程在使用了，就会不断地轮询第三方存储介质看其他进程是否释放掉该锁；当进程操作完该数据后，该进程就到第三方存储介质中把该锁id删除掉，这样其他轮询的进程就能得到对该锁的控制。

Redis中当然不能通过get,set操作判断，get,set操作不是一个原子的，可以使用redis的`jedis.set(String key, String value, String nxxx, String expx, int time)`命令来保证原子性。

1. 数据库乐观锁；
2. 基于Redis的分布式锁；
3. 基于ZooKeeper的分布式锁。

### 传统数据库mysql乐观锁



### Redis分布式锁

其实redis也可以像mysql那样设计

看redis.md文章



### 数据库

更新mysql的多行数据，可以使用表锁，也可以使用分布式锁。

### **数据库访问量过大除了主从还能如何负载压力？**

　　数据库会为客户端的每一个请求创建一个线程，这些线程针对特定行数据修改必须获得该行的行锁，而其他客户端线程要想修改该数据的话，必须等待前面的线程释放锁后才被允许。如果客户端很多线程都要修改某行数据的话，没有拿到锁的线程都会在数据库端机器上不断轮询，增大数据库端的压力。

　　我们可以使用分布式锁，把对数据库行锁的等待获取的轮询放到每一个客户端机器上去实现，这样可以避免数据库端线程的不断轮询。比如，客户端在要发送对数据库的某行数据的操作请求前，在客户端机器上进行锁的争抢，没有获取到锁，就不会像数据库端发送操作请求，这样数据库端就没有了轮询的压力。当然分布式锁的引入一定要结合业务的需求来进行设计，不然会出现锁id的命名不全导致读取的数据不一致，数据过期失效等问题。

# 参考文献