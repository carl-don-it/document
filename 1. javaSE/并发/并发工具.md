# ThreadPoolExecutor

`java.util.concurrent.ThreadPoolExecutor#addWorker`

1. 先检查pool的state，如果不适合，那么就不创建。

2. 如果worker count不越界，那么就创建worker，先修改worker count。如果修改成功，进入下一环节，正式创建worker，否则，要重新检查pool state，再尝试修改worker count。

3. 正式创建线程，有可能创建失败，或者线程已经启动了，这些都不是符合要求的。

   创建前先检查状态，如果不符合，那么不创建，如果最后没有成功运行，那么需要删除。

[Java并发 之 线程池系列 (2) 使用ThreadPoolExecutor构造线程池](https://juejin.cn/post/6844903811299934221#heading-9)

> Executors的缺点，不要使用和如何使用

[Java 线程池源码详解(1)-基本线程池解析](https://blog.csdn.net/weixin_45505313/article/details/100675296)

> 普通线程池的说法，作者看起来挺牛的样子

# ForkJoinPool

## 方法

### java.util.concurrent.ForkJoinPool#helpStealer

> jdk8

找到偷任务的workqueue，或者是后代，如果workqueue有多余的任务，那就偷来执行。多次没有找到并且稳定那就退出方法。

> 漏洞之一：
>
> 任务互相循环偷而且有依赖的可能结局：1被2偷a，1等a，a生b，1帮2，1偷2的b来玩；2开始帮1，1没有，只能帮1的等，1等2，那就转去帮2；2没有，只能帮2的等，2等1，那就转去帮1；这就死循环了，只能等1完成b才能退出。---理论上，我还没实践过。

> 漏洞之二
>
> 如果被偷的任务被阻塞了，并且需要join，比如io什么的，原来队列如果找不到任务偷来执行那就会循环，或者是compensate一个，但是阻塞的那个线程是没有办法compensate的

## 其他细节

1. 最多只需要126/2+1=64个供外部使用的共享队列

   ```java
   static final int SQMASK       = 0x007e;        // max 64 (even) slots
   ```

2. 不知道为什么要空一个出来

   ```java
    (am = a.length - 1) > (n = (s = q.top) - q.base)
   ```

3. ```java
   U.compareAndSwapInt(q, QLOCK, 0, 1)) {
             ForkJoinTask<?>[] a; int am, n, s;
             if ((a = q.array) != null &&
                 (am = a.length - 1) > (n = (s = q.top) - q.base)) {
                 int j = ((am & s) << ASHIFT) + ABASE;
                 U.putOrderedObject(a, j, task);
                 U.putOrderedInt(q, QTOP, s + 1);
                 U.putIntVolatile(q, QLOCK, 0);
                 if (n <= 1)
                     signalWork(ws, q);
                 return;
             }
   //            为什么这里不能直接   U.putIntVolatile(q, QLOCK, 0);
               U.compareAndSwapInt(q, QLOCK, 1, 0);
   ```

   

将一个大任务拆分成很多个小任务来执行，而最终又将每个小任务执行的结果进行合并，最终完成这一大块任务.**只要能够通过递归来实现的应用场景都可以使用fork/join框架来提高性能**

例子： [ForkJoinPool并发处理框架](https://juejin.cn/post/6912688411778220039)

而因为是双端的，刚加入的队头也可以取任务（这也就是证明了，为什么上述分析的join方法源码，会判断该任务是否被其他线程优先取走）；

这种好处是显而易见的，可以减少并发的冲突，因为在大并发的情况下，queue的长度很长，窃取任务几乎不会遇到阻塞，采用CAS无锁算法会轻而易举的窃取成功；

ForkJoinPool除了完成基本的线程池的任务Thread计算的功能，还可以完成map，reduce的思想；

## 引用资料

### 1. 重要

[java线程池(五)：ForkJoinPool源码分析之一(外部提交及worker执行过程)](https://cloud.tencent.com/developer/article/1705833)

[Java 线程池源码详解(2)-ForkJoinPool 源码解析](https://blog.csdn.net/weixin_45505313/article/details/106149829)

[ForkJoinPool源码解析（一）-- 初始化](https://www.cnblogs.com/juniorMa/articles/14241296.html)

[Executor（五）：ForkJoinPool详解 jdk1.8](https://blog.csdn.net/lcbushihaha/article/details/104449454)

> 很详细

### 2 中等

[Fork/Join框架原理解析](Fork/Join框架原理解析)

> 还行，值得一看

[ForkJoinPool源码分析之二](https://www.modb.pro/db/221785)

> 大概思想和想法

[ForkJoinPool源码分析](https://juejin.cn/post/6844904195292659719)

> 简单的源码堆积，说明细节不多，但是具体流程还是有的

[工作窃取算法 work-stealing](https://blog.csdn.net/pange1991/article/details/80944797)

### 3 例子

[Java多线程之ThreadPoolExecutor和ForkJoinPool的用法](https://juejin.cn/post/6844903870896799751)

[Fork/Join框架基本使用](Fork/Join框架基本使用)

> 更有效地用法有点疑问

[分而治之Fork-Join 框架](https://juejin.cn/post/6844903941411438606)

# CompletableFuture

[Java CompletableFuture(1)-使用详解](https://blog.csdn.net/weixin_45505313/article/details/114178407)

Java CompletableFuture(2)-原理详解