[从根上理解用户态与内核态](https://segmentfault.com/a/1190000039774784)

[原来 8 张图，就可以搞懂「零拷贝」了](https://www.cnblogs.com/xiaolincoding/p/13719610.html)

[深入剖析Linux IO原理和几种零拷贝机制的实现](https://zhuanlan.zhihu.com/p/83398714)

[内存映射为何能提升IO读取速率？](https://www.codenong.com/cs109393789/)

[Java直接内存原理](https://juejin.cn/post/6844903822091878408)

[Java直接内存与堆内存](https://www.cnblogs.com/z-sm/p/6235157.html)

[Java-直接内存 DirectMemory 详解](https://cloud.tencent.com/developer/article/1586341)

> 《深入理解 Java 虚拟机 第三版》2.2.7 小节 关于 Java 直接内存的描述。
>
> 直接内存出现 OutOfMemoryError 异常的原因是物理机器的内存是受限的。
>
> JNI（Java Native Inteface）在调用 IO 操作的 C 类库时，规定了写入时地址不能失效，这就导致了不能在 heap 上直接进行 IO 操作。
>
> 直接内存的最大大小可以通过 `-XX:MaxDirectMemorySize` 来设置，默认是 64M。
>
> ![1648280536541](img/1648280536541.png)
>
> DirectByteBuffer 这种申请堆外内存的方式比堆内申请内存效率低，这主要是因为前者需要向物理机申请堆外内存，这是额外的开销。

[深入剖析Linux IO原理和几种零拷贝机制的实现，重点](https://zhuanlan.zhihu.com/p/83398714)

[Java直接内存是属于内核态还是用户态？](https://www.zhihu.com/question/376317973)

> 其实本质是减少内存之间拷贝的次数，因为DirectMemory直接分配的是用户空间的内存，所以不再需要用户空间和jvm的heap之间的拷贝，所以少了一次拷贝，节省了时间。然而这只是用户态上的空间优化，那么用户态和内核态之间是否又被优化了呢。
>
> 用户态和内核态之间的拷贝其实也被优化了，本质上是因为用户态的[逻辑地址](https://www.zhihu.com/search?q=逻辑地址&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1054580772})和内核态的逻辑地址使用的是同一个物理空间，所以相当于用户态和内核态也不存在拷贝。
>
> 在堆外内存中如果我们是通过Java的directbuffer申请的，那么这块内存其实也是间接受gc管理的，而如果我们通过jni直接调用c函数申请一块堆外内存，那么这块内存就只能我们自己手动管理了。
>
> 直接将数据写到堆外内存中，然后堆内内存中有个引用地址来操作这个堆外内存。

[搞懂IO](https://zhuanlan.zhihu.com/p/100014103)

> linux操作系统内核尚未实现aio(windows 实现了aio)。
>
> 网络io就是对网卡的读写。
>
> 有人说，传统的bio也有buffer的，比如bufferxxx类，但是传统的buffer操作还是没法和nio的buffer相比。
>
> 在jdk1.4之后的transferTo方法就是零拷贝的实现。
> 所以下次两个文件之间的复制，或者文件到socket的复制，应该想到使用transferTo方法

1. 物理内存  
2. 虚拟内存
3. 页表
4. 用户进程
5. 磁盘存储空间
6. 内核空间和用户空间
7. i/o中原理
8. dma传输原理
9. 传统的io
10. 用户态直接io
11. mmap + write
12. Sendfile
13. sendfile + DMA      gather copy
14. Splice
15. 写时复制
16. 缓冲区共享
17. Linux零拷贝对比